# Лабораторная №1 "калькулятор". Сложность М2

## Введение
Данный шаблон является примером оформления кода для сдачи лабораторных работ.
Рекомендуется  строго его придерживаться во избежания проблем при сдаче и понижения баллов

## Ввод

Пользователь активирует файл [main.py](./src/main.py) через ввод команды `py -m src.main` в терминале 
Далее пользователь вводит математическое выражение, состоящее из:
- Операндов (Все вещественные числа)
- Операторов:
- - Сложение +
  - Вычетание -
  - Умножение *
  - Деление / 
  - Возведение в степень **
  - Деление нацело //
  - Остаток от деления %
 
После работы программа печатает ответ - вещественное число, округлённое до 6-го знака

## Алгоритм

Алгоритм представляет собой последовательность выполнения следующиз основных функций в файле [main.py](./src/main.py):
1. `parse()` из [parse.py](./src/parse.py) - парсирует входное выражение, разбивая его на токены для чисел и операций
2. `check_mistakes()` из [Errors.py](./src/errors.py) - проверяет парсированное выражение на ошибки синтаксиса
3. `to_polish()` из [to_polish.py](./src/to_polish.py) - переводит выражение в обратную польскую запись
4. `calc_polish()` из [to_polish.py](./src/calc_polish.py) - подсчитывает выражение в польской записи и выдаёт ответ на него

## Мои решения

### Парсинг
Функция `parse()` на токены разбивает их на два типа: `("NUM", float(x))` и `("operation", None)` для избежания создания шаблонов двух токенов и сохранения чёткой типизации `Token = (str, float | None)`. Сам шаблон парсинга лежит в константе `TOKEN_RE`, где я выделяю числа с унарными знаками и операции. Это удобно, так как позволяет не добавлять лишние проверки на унарные знаки, а сделать парсинг числа со знаком, если они находятся вплотную (например -1). То есть запись `1+1` будет парсированна как [("NUM", 1.0), ("NUM", +1.0). Это сделано для унификации парсинга положительных и отрицательных унарных знаков, так что при использовании сложения или вычитания, они должны быть отделены от последующих / предыдущих чисел. Для реализации функции и токенизации были использованы функции re.compile() и re.match() из библиотеки re. 

### Проверка ошибок
В файле `errors` находится класс для вызова ошибок, а также функция `check_mistakes`. Она проверяет исходное выражение на ошибки. За ошибки я считал:
- Ошибки, касающиеся ошибочного ввода несокльких чисел \ операций (оператор перед закрывающей скобкой, число перед октрывающей скобкой и т.д.)
- Несовподающее число скобок

Но за ошибку не считается нахождение в скобках числа, что сделано для удобства ввода, так как в обычных умных калькуляторах (например photomath) это не считается ошибкой

Я не делал несколько классов ошибок, так как ошибки для их отслеживания можно прописать в одном классе. Исключение - ошибки, связанные со стэками, так как они используют стандартные действия со списками, вызывающими ошибку `InexError()` (далее в документации)

### Перевод в обратную польскую запись
Функция `to_polish` переводит обычную запись в обратную польскую нотацию. Она это делает по стандартному алгоритму перевода через стэк с учётом иерархии операций, находящейся в словаре `hierarchy`. Это удобно, так как последующий алгоритм вычисления выражения сильно упрощается, а также перевод учитывает скобки и учитывает унарные знаки, считая числа с ними на равне с обычными.

В переводе, а также подсчёте польской записи используются отдельные команды для работа со стэками в файле [stack.py](./src/stack.py). Они нужны для более удобной и наглядной работы со стэком, а также обработки ошибок при работе с ним.

### Подсчёт польской записи
Функция `calc_polish` подсчитывает запись в обратной польской нотации. Аналогично предыдущей функции она использует стандартный метод посчёта польской записи через стэк. Для вычисления конкретных оперций с числами я сделал функцию `calc()` в файле [calc.py](./src/calc.py). Она получает на вход три токена: два операнда и одну операцию, а дальше применяет к ним сответсующую операцию. При делении на ноль выдаётся ошибка, так же как при проведении операции целения нацело и деления с остатком над нецелыми числами, потому что это невозможно чисто математически и так написано в требованиях к работе. В итоге функция подсчёта полькой записи выдаёт вещественное число, округлённое до 6-го знака для удобства просмотра ответа и наглядности

### Тесты 
Тесты были сделаны при помощи `pytest`, используя прогонку нескольких заданных значений через один тест для удобства тестирования. В тестах учитываются как нормлаьные результаты работы функций, так и крайные варианты, вызвающие ошибки

## Структура проекта

 <pre>
    .
    ├── lab<# лабораторной работы>             # Кодовая база вашей лабораторной работы
    │   ├── src/                               # Исходный код
    │   ├── tests/                             # Unit тесты
    │   ├── uv.lock                            # зависимости вашего проекта
    │   ├── report.pdf                         # Отчет
    │   ├── .gitignore                         # git ignore файл
    │   ├──.pre-commit-config.yaml             # Средства автоматизации проверки кодстайла
    │   ├── README.md                          # Описание вашего проекта, с описанием файлов и с титульником о том,
                                               # что и какая задача
</pre>

В папке [src](./src) лежат файлы с реализацией задачи заданной в лабораторной работе. Обязательным файлом является файл
[main.py](./src/main.py) в котором описана точка входа в приложение - функция **main**. Требования к коду:
- Переменные, функции и модули именуются по [**snake_case**](https://realpython.com/ref/glossary/snake-case/)
- Константы должны быть вынесены в файл **constants.py** и именовановаться с помощию символов в верхнем регистре
- Классы должны именоваться в [**PascalCase**](https://habr.com/ru/articles/724556/)
- Имена сущностей должны быть осмысленные и содержательные
- Все отступы должны быть консистентны: 1 TAB = 4 spaces
- Весь функционал должен быть описан в функциях и в классах. Не допускается писать весь в глобальном скоупе или в одной функции
- К каждой функции должны быть описаны  [**docstring**](https://peps.python.org/pep-0257/) и аннотации к аргументам и выходным параметрам функций.

В качестве референса проще cходу соблюдать [**PEP8**](https://peps.python.org/pep-0008/) и использовать IDE c готовой поддержкой:
например PyCharm или VSCode c настроенными плагинами.
В ходе попыток запушить код в репозиторий ваш код будет проходить проверку статическим анализатором [**mypy**](https://mypy-lang.org/)
а также с встроенным в [**ruff**](https://astral.sh/ruff) на предмет нарушения код стайла. При работе с кодовой базой
всю работу необходимо выполнять в [виртуальном окружении](https://docs.python.org/3/tutorial/venv.html)


В папке [tests](./tests) лежат [unit тесты](https://tproger.ru/articles/testiruem-na-python-unittest-i-pytest-instrukcija-dlja-nachinajushhih) для проверки функциональности программы или ее частей.
Рекомендуется использовать pytest. Также название тестов должно быть осмысленно и содержать определение проверямой части.
Базовые соглашения pytest можно посмотреть [здесь](https://www.qabash.com/pytest-default-naming-conventions-guide/).
Рекомендуется проверять не только успешные кейсы, но и краевые условия и кейсы в которых была допущена ошибка (неудачные кейсы).

В качестве пакетного менджера в данном шаблоне/репозитории используется [uv](https://github.com/astral-sh/uv).
Можно использовать и [стандартные виртальные окружения](https://docs.python.org/3/library/venv.html). В таком случае необходимо добавить в репозиторий `requirements.txt`.
Это достигается командой
```shell
pip freeze > requirements.txt
```
Также разрешается использовать [`poetry`](https://python-poetry.org/)
## Как работать с репозиторием и шаблонами
1. Необходимо создать репозиторий из этого шаблона. Посмотреть можно [здесь](https://docs.github.com/ru/repositories/creating-and-managing-repositories/creating-a-repository-from-a-template)
2. Склонировать или спуллить его к себе на машину командами `git pull` или `git clone`
3. Создать виртуальное окружение:

    a. Для uv прописать команду `uv venv`. Затем прописать `.venv/bin/activate` в терминале

    b. Для обычного python `python -m venv <имя директории где будет храниться папка .venv>`. Затем прописать `.venv/bin/activate` в терминале
4. Установить [`pre-commit`](https://pre-commit.com/). Для этого достаточно ввести команду `pip install pre-commit`
5. Выполнить команду `pre-commit install`
6. При запушивании в репозиторий необходимо правильно составлять сообщения коммита. Правила можно прочитать [здесь](https://github.com/RomuloOliveira/commit-messages-guide/blob/master/README_ru-RU.md)
7. **Внимательно** читайте то, что пишется при попытке коммита, если исправили ошибки нужно заново добавить отредактированные файлы в гит и попробовать коммитнуть
